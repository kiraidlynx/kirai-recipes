---
title: "Algoritmos de limpieza de datos"
author: "Ccanadas"
date: "2022-09-12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Lectura de datos


# Limpieza de datos NAs

## Borrado de NAs

## Reemplazo por muestra aleatoria:

Susituye un conjunto de valores NA por una muestra simple aleatoria de un conjunto de valores que existan.
Es decir, almacenamos los valores existentes en un vector y para cada valor NA dentro de ese vector se sustituye de manera aleatoria por un valor almacenado.

```{r mas}

#x es un vector de datos que puede contener NA
rand.impute <- function(x) {
  # missing contiene un vector de valores T/F dependiendo del NA de x
  missing <- is.na(x)
  #n.missing contiene cuantos valores son NA dentro de x
  n.missing <- sum(missing)
  #x.obs son los valores conocidos que tienen dato diferente de NA en x
  x.obs <- x[!missing]
  #por defecto, devolveré lo mismo que había entrado por parámetro
  imputed <- x
  #en los valores que faltaban, los reemplazamos por una muestra
  #de los que si conocemos (MAS)
  imputed[missing] <- sample(x.obs, n.missing, replace = TRUE)
  return (imputed)
}


##ESTA ES LA FUNCIÓN A LA QUE HAY QUE LLAMAR
random.impute.data.frame <- function(dataframe, cols){
  names <- names(dataframe)
  for(col in cols){
    name <- paste(names[col], "imputed", sep = ".")
    dataframe[name] = rand.impute(dataframe[,col])
  }
  dataframe
}



```


# Limpieza de duplicados


# Reescalado y normalizado

## Función de reescalado lineal:

Toma una columna de un dataframe y los reescala de 0 a 1 a partir de la fórmula
$$y_i=\frac{x_i-min(x)}{max(x)-min(x)} $$ 

```{r reescalado}

rescale.many <- function(dataframe, cols){
  names <- names(dataframe)
  for(col in cols){
    name <- paste(names[col], "rescaled", sep = ".")
    dataframe[name] <- rescale(dataframe[,col]) 
  }
  cat(paste("Hemos reescalado ", length(cols), " variable(s)"))
  dataframe
}



```


## Función de normalizado

Aplica una camapana de Gauss estandarizada a las columnas del daframe que queramos normalizar a partir de la fórmula:

$$Z=\frac{X-\mu}{\sigma} $$

```{r normalizado}

scale.many = function(dataframe, cols){
  names <- names(dataframe)
  for(col in cols){
    name <- paste(names[col], "z", sep = ".")
    dataframe[name] <- scale(dataframe[,col])
  }
  cat(paste("Hemos normalizado ", length(cols), " variable(s)"))
  dataframe
}



```

# Preparación de datos


# Corrección de datos

## Enmascarar outliers (IMPUTE)

Imputa los valores por debajo del cuantil 5% por la media y los que estén por encima del 95% por la mediana


```{r imputeol}


impute_outliers <- function(x, removeNA = TRUE){
  quantiles <- quantile(x, c(0.05, 0.95), na.rm = removeNA)
  x[x<quantiles[1]] <- mean(x, na.rm = removeNA)
  x[x>quantiles[2]] <- median(x, na.rm = removeNA)
  x
}

```

## Enmascarar outliers (REPLACE) 

Capping: sustituye los outliers por valores que estén en los extremos de los bigotes


```{r replaceol}


replace_outliers <- function(x, removeNA = TRUE){
  qrts <- quantile(x, probs = c(0.25, 0.75), na.rm = removeNA)
  caps <- quantile(x, probs = c(.05, .95), na.rm = removeNA)
  iqr <- qrts[2]-qrts[1]
  h <- 1.5 * iqr
  x[x<qrts[1]-h] <- caps[1]
  x[x>qrts[2]+h] <- caps[2]
  x
}


```






















